שאלות ידע:
מערך מול רשימה מקושרת:
מערך: נמצא בזכרון כבלוק כך שהאלמנטים ממוקמים באופן רציף
רשימה: האיברים מפוזרים בזכרון עם רפרנס לאיבר הבא
הכנסה למערך: אם זה בסוך אז מהיר, אם לא אז יכול להיות o(n)
רשימה:

In summary, arrays are better suited for scenarios where random access and memory locality are important, and the size of the collection is known in advance or doesn't change frequently. On the other hand, linked lists are more appropriate when frequent insertions and deletions are required, or when the size of the collection can change dynamically.

מערך: כאשר ידוע מראש הגודל וגודל המערך לא משתנה כל הזמן
רשימה: כאשר משתנה כל הזצן הגודל ויש הכנסות והוצאות כל הזמן

שפות תכנות:
C: תכנות פרוצדורלי: תבנית תכנות או גישה עצובית של כתיבת הקוד. למשל ב C, מחולק לאוסף של פונקציו תהקוראות אחת לשניה. ניתן ב C לתחזק את הזכרון עם מצביעים. משומש בעיקר בתוכנות שעוסקות בעיקר באינטראקציה עם החומרה ומערכת ההפעלה של המחשב
C++, JAVA:  כאן הגישה היא תכנות מונחה עצמים שבין העצמים קיימת הירריכה ויחסים מסויימים. 
פייתון: כאן יש מפענח, כלומר הקוד לא מקומפל לפני הריצה. כאן יש טיפוסים דינאמיים, מוגדרים בזמן ריצה. משתמשת לscientific computing, data analysis, machine learning web. יש לה ספריות רבות, סינטקס קל, קהילה גדולה ודוקומנטציה.
JavaScript:גם כאן שפה עם מפענח, לרוב משומשת בצד לקוח. even loop:
ה-stack:
כאן נשמרות הקריאות לפונקציות. אם יש קריאה לפונקציה פו, היא מתווספת לסטאק, ואם היא קראה לפונקציה באז, אז באז מתווספת לסטאק מעליה, ועד שבאז לא מסתיימת, ג'אווהסקריפט לא חוזרת לפו. 
Event loop:
רכיב שתפקידו לבדוק אם הסטאק ריק, ואם הוא ריק לקחת משימה מה-
callback queue
ולהעביר אותה לסטאק.
Web API:
זה ממשק חיצוני, שקשור בדפדפן, ואחראי על הרצה של משימות אסינכרוניות (כמו קריאות לשרת).
כמובן שגם בנוד (וגם בסביבות אחרות), יש מקבילה לזה, שאחראית על הרצת משימות אסינכרוניות.

כשה-runtime מריץ פונקציה "רגילה" של קוד (כלומר סינכרונית) - היא מתווספת ל-call stack, ואז מתבצעת, ומוצאת משם.

כשהוא מריץ פקודה א-סינכרונית, הפקודה היא למעשה קריאה ל-web api (ולכן הת'רד יכול להמשיך בענייניו ולהריץ את פקודות מהסטאק).

ה-runtime קורא לפקודה מה-web api, וממשיך להריץ פקודות מהסטאק.

כשה-web api מסיים את הפקודה (נגיד הנתונים חזרו מהשרת), הוא מוסיף את הקוד שצריך הרצה ל- callback queue.

ה-event loop מחכה שהסטאק יהיה ריק, ואז לוקח את המשימה הבאה מה-callback queue, ומעביר אותה לסטאק, להרצה.

כך שהטריק הוא שקוד א-סינכורני לא באמת רץ בת'רד של ג'אווהסקריפט, וג'אווהסקריפט רק מתקשרת עם התוצאות של ההרצות האלה (כשאין לה משהו אחר לעשות).
https://www.youtube.com/watch?v=lqLSNG_79lI&ab_channel=JamesQQuick

event loop:
callStack: מה שנכנס ישר מבוצע אם לא א-סינכרוני.
webAPI: מגיע אליו דרך call stack, הוא שולח את כל א-סינכרוני
task queueץ כאן נשלח משימות אסינכרוניות בעדיםות גבוהה.
evebt queue: לכאן נכסו המשימות אחרי שסיימו את מה שביצעו ב webAPI.
event loop. יבדוק גאשר callstack ריק יבדוק את event queue (קודם יבדוק את טסק קיו) וזש ישלח משם ל call stack.
ASYNC/AWAIT
כאן נוצר המתנה בתוך הפונקציה המוגדרת א-סינכרונית. אבל מחוץ לפונקציה לא תהיה המתנה.